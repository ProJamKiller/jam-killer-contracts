(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3207],{21187:(e,t,r)=>{"use strict";r.d(t,{E:()=>o,R:()=>n,S:()=>l,a:()=>u});var a=r(37457),i=r(14476),s=r(27454);let n=i.z.union([i.z.date().transform(e=>a.gH.from(Math.floor(e.getTime()/1e3))),i.z.number().transform(e=>a.gH.from(e))]),l=n.default(new Date(0)),o=n.default(new Date(Date.now()+31536e7));function u(e,t){if(!e)throw new s.x(t);return e}},17152:(e,t,r)=>{"use strict";r.d(t,{B:()=>o,C:()=>u,N:()=>f,a:()=>h,s:()=>c});var a=r(27454),i=r(14476),s=r(95848);let n=i.z.object({}).catchall(i.z.union([a.cx,i.z.unknown()])),l=i.z.union([i.z.array(i.z.array(n)).transform(e=>e.flat()),i.z.array(n),n]).optional().nullable(),o=i.z.object({name:i.z.union([i.z.string(),i.z.number()]).optional().nullable(),description:i.z.string().nullable().optional().nullable(),image:a.cy.nullable().optional(),animation_url:a.cy.optional().nullable()}),u=o.extend({external_url:a.cy.nullable().optional(),background_color:a.cz.optional().nullable(),properties:l,attributes:l}).catchall(i.z.union([a.cx,i.z.unknown()])),f=i.z.union([u,i.z.string()]),h=u.extend({id:i.z.string(),uri:i.z.string(),image:i.z.string().nullable().optional(),external_url:i.z.string().nullable().optional(),animation_url:i.z.string().nullable().optional()});async function c(e,t,i,n){if((0,s.i)(i))n.value=t;else{let s=(await Promise.resolve().then(r.t.bind(r,96337,19))).default,l=e.getSigner(),o=e.getProvider(),u=new a.cs(l||o,i,s,e.options,e.storage),f=await e.getSignerAddress(),h=e.address;return(await u.read("allowance",[f,h])).lt(t)&&await u.sendTransaction("approve",[h,t]),n}}},73207:(e,t,r)=>{"use strict";r.d(t,{A:()=>E,B:()=>X,C:()=>G,D:()=>L,E:()=>R,F:()=>I,H:()=>$,I:()=>C,J:()=>A,K:()=>K,L:()=>Q,M:()=>eo,S:()=>ee,a:()=>M,f:()=>N,n:()=>et,r:()=>ei,s:()=>es,t:()=>en,u:()=>el,v:()=>eu,w:()=>ef,x:()=>eh,y:()=>Y,z:()=>O});var a=r(43514),i=r(65579),s=r(47197),n=r(48892),l=r(50234),o=r(37457),u=r(8471),f=r(71414),h=r(27454),c=r(95848),m=r(29966),d=r(48287),p=r(18924),y=r.n(p),g=r(22539);class b{print(){b.print(this)}bufferIndexOf(e,t){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return r?this.binarySearch(e,t,d.Buffer.compare):this.linearSearch(e,t,(e,t)=>e.equals(t))}static binarySearch(e,t,r){let a=0,i=e.length-1;for(;a<=i;){let s=Math.floor((a+i)/2),n=r(e[s],t);if(0===n){for(let a=s-1;a>=0;a--)if(0!==r(e[a],t))return a+1;return 0}n<0?a=s+1:i=s-1}return -1}binarySearch(e,t,r){return b.binarySearch(e,t,r)}static linearSearch(e,t,r){for(let a=0;a<e.length;a++)if(r(e[a],t))return a;return -1}linearSearch(e,t,r){return b.linearSearch(e,t,r)}static bufferify(e){if(!d.Buffer.isBuffer(e)){if("object"==typeof e&&e.words)return d.Buffer.from(e.toString(v),"hex");if(b.isHexString(e))return d.Buffer.from(e.replace(/^0x/,""),"hex");if("string"==typeof e)return d.Buffer.from(e);if("bigint"==typeof e)return d.Buffer.from(e.toString(16),"hex");else if(e instanceof Uint8Array)return d.Buffer.from(e.buffer);else if("number"==typeof e){let t=e.toString();return t.length%2&&(t=`0${t}`),d.Buffer.from(t,"hex")}else if(ArrayBuffer.isView(e))return d.Buffer.from(e.buffer,e.byteOffset,e.byteLength)}return e}bigNumberify(e){return b.bigNumberify(e)}static bigNumberify(e){if("bigint"==typeof e)return e;if("string"==typeof e)return e.startsWith("0x")&&b.isHexString(e)?BigInt("0x"+e.replace("0x","").toString()):BigInt(e);if(d.Buffer.isBuffer(e))return BigInt("0x"+e.toString("hex"));if(e instanceof Uint8Array)return function(e){let t=Array.from(e).map(e=>e.toString(16).padStart(2,"0")).join("");return BigInt(`0x${t}`)}(e);if("number"==typeof e)return BigInt(e);throw Error("cannot bigNumberify")}static isHexString(e){return"string"==typeof e&&/^(0x)?[0-9A-Fa-f]*$/.test(e)}static print(e){console.log(e.toString())}bufferToHex(e){let t=!(arguments.length>1)||void 0===arguments[1]||arguments[1];return b.bufferToHex(e,t)}static bufferToHex(e){let t=!(arguments.length>1)||void 0===arguments[1]||arguments[1];return`${t?"0x":""}${(e||d.Buffer.alloc(0)).toString("hex")}`}bufferify(e){return b.bufferify(e)}bufferifyFn(e){return t=>{var r;let a=e(t);if(d.Buffer.isBuffer(a))return a;if(this.isHexString(a))return d.Buffer.from(a.replace("0x",""),"hex");if("string"==typeof a)return d.Buffer.from(a);if("bigint"==typeof a)return d.Buffer.from(t.toString(16),"hex");if(ArrayBuffer.isView(a))return d.Buffer.from(a.buffer,a.byteOffset,a.byteLength);let i=(r=e(function(e){let t=new Uint8Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=parseInt(e.substring(r,r+2),16);return t.buffer}(t.toString("hex"))),Array.from(new Uint8Array(r)).map(e=>e.toString(16).padStart(2,"0")).join(""));return d.Buffer.from(i,"hex")}}isHexString(e){return b.isHexString(e)}log2(e){return 1===e?0:1+this.log2(e/2|0)}zip(e,t){return e.map((e,r)=>[e,t[r]])}static hexZeroPad(e,t){return"0x"+e.replace("0x","").padStart(t,"0")}}var w=b;function v(e){let t=e.words,r=new ArrayBuffer(4*t.length),a=new Uint8Array(r);for(let e=0;e<t.length;e++)a[4*e]=t[e]>>24&255,a[4*e+1]=t[e]>>16&255,a[4*e+2]=t[e]>>8&255,a[4*e+3]=255&t[e];return r}class x extends w{duplicateOdd=!1;concatenator=d.Buffer.concat;hashLeaves=!1;isBitcoinTree=!1;leaves=[];layers=[];sortLeaves=!1;sortPairs=!1;sort=!1;fillDefaultHash=null;complete=!1;constructor(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(super(),r.complete){if(r.isBitcoinTree)throw Error('option "complete" is incompatible with "isBitcoinTree"');if(r.duplicateOdd)throw Error('option "complete" is incompatible with "duplicateOdd"')}if(this.isBitcoinTree=!!r.isBitcoinTree,this.hashLeaves=!!r.hashLeaves,this.sortLeaves=!!r.sortLeaves,this.sortPairs=!!r.sortPairs,this.complete=!!r.complete,r.fillDefaultHash){if("function"==typeof r.fillDefaultHash)this.fillDefaultHash=r.fillDefaultHash;else if(d.Buffer.isBuffer(r.fillDefaultHash)||"string"==typeof r.fillDefaultHash)this.fillDefaultHash=(e,t)=>r.fillDefaultHash;else throw Error('method "fillDefaultHash" must be a function, Buffer, or string')}this.sort=!!r.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!r.duplicateOdd,r.concatenator&&(this.concatenator=r.concatenator),this.hashFn=this.bufferifyFn(t),this.processLeaves(e)}getOptions(){return{complete:this.complete,isBitcoinTree:this.isBitcoinTree,hashLeaves:this.hashLeaves,sortLeaves:this.sortLeaves,sortPairs:this.sortPairs,sort:this.sort,fillDefaultHash:this.fillDefaultHash?.toString()??null,duplicateOdd:this.duplicateOdd}}processLeaves(e){if(this.hashLeaves&&(e=e.map(this.hashFn)),this.leaves=e.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(d.Buffer.compare)),this.fillDefaultHash)for(let e=this.leaves.length;e<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));e++)this.leaves.push(this.bufferify(this.fillDefaultHash(e,this.hashFn)));this.createHashes(this.leaves)}createHashes(e){for(this.layers=[e];e.length>1;){let t=this.layers.length;this.layers.push([]);let r=this.complete&&1===t&&!Number.isInteger(Math.log2(e.length))?2*e.length-2**Math.ceil(Math.log2(e.length)):e.length;for(let a=0;a<e.length;a+=2){if(a>=r){this.layers[t].push(...e.slice(r));break}if(a+1===e.length&&e.length%2==1){let r=e[e.length-1],i=r;if(this.isBitcoinTree){i=this.hashFn(this.concatenator([y()(r),y()(r)])),i=y()(this.hashFn(i)),this.layers[t].push(i);continue}if(this.duplicateOdd);else{this.layers[t].push(e[a]);continue}}let i=e[a],s=a+1===e.length?i:e[a+1],n=null;n=this.isBitcoinTree?[y()(i),y()(s)]:[i,s],this.sortPairs&&n.sort(d.Buffer.compare);let l=this.hashFn(this.concatenator(n));this.isBitcoinTree&&(l=y()(this.hashFn(l))),this.layers[t].push(l)}e=this.layers[t]}}addLeaf(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];t&&(e=this.hashFn(e)),this.processLeaves(this.leaves.concat(e))}addLeaves(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];t&&(e=e.map(this.hashFn)),this.processLeaves(this.leaves.concat(e))}getLeaves(e){return Array.isArray(e)?(this.hashLeaves&&(e=e.map(this.hashFn),this.sortLeaves&&(e=e.sort(d.Buffer.compare))),this.leaves.filter(t=>-1!==this.bufferIndexOf(e,t,this.sortLeaves))):this.leaves}getLeaf(e){return e<0||e>this.leaves.length-1?d.Buffer.from([]):this.leaves[e]}getLeafIndex(e){e=this.bufferify(e);let t=this.getLeaves();for(let r=0;r<t.length;r++)if(t[r].equals(e))return r;return -1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map(e=>this.bufferToHex(e))}static marshalLeaves(e){return JSON.stringify(e.map(e=>x.bufferToHex(e)),null,2)}static unmarshalLeaves(e){let t=null;if("string"==typeof e)t=JSON.parse(e);else if(e instanceof Object)t=e;else throw Error("Expected type of string or object");if(!t)return[];if(!Array.isArray(t))throw Error("Expected JSON string to be array");return t.map(x.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce((e,t)=>(Array.isArray(t)?e.push(t.map(e=>this.bufferToHex(e))):e.push(t),e),[])}getLayersFlat(){let e=this.layers.reduce((e,t)=>(Array.isArray(t)?e.unshift(...t):e.unshift(t),e),[]);return e.unshift(d.Buffer.from([0])),e}getHexLayersFlat(){return this.getLayersFlat().map(e=>this.bufferToHex(e))}getLayerCount(){return this.getLayers().length}getRoot(){return 0===this.layers.length?d.Buffer.from([]):this.layers[this.layers.length-1][0]||d.Buffer.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(e,t){if(void 0===e)throw Error("leaf is required");e=this.bufferify(e);let r=[];if(!Number.isInteger(t)){t=-1;for(let r=0;r<this.leaves.length;r++)0===d.Buffer.compare(e,this.leaves[r])&&(t=r)}if(t<=-1)return[];for(let e=0;e<this.layers.length;e++){let a=this.layers[e],i=t%2,s=i?t-1:this.isBitcoinTree&&t===a.length-1&&e<this.layers.length-1?t:t+1;s<a.length&&r.push({position:i?"left":"right",data:a[s]}),t=t/2|0}return r}getHexProof(e,t){return this.getProof(e,t).map(e=>this.bufferToHex(e.data))}getProofs(){let e=[];return this.getProofsDFS(this.layers.length-1,0,[],e),e}getProofsDFS(e,t,r,a){let i=t%2;if(-1===e){i||a.push([...r].reverse());return}if(t>=this.layers[e].length)return;let s=this.layers[e],n=i?t-1:t+1,l=!1;n<s.length&&(l=!0,r.push({position:i?"left":"right",data:s[n]})),this.getProofsDFS(e-1,2*t,r,a),this.getProofsDFS(e-1,2*t+1,r,a),l&&r.splice(r.length-1,1)}getHexProofs(){return this.getProofs().map(e=>this.bufferToHex(e.data))}getPositionalHexProof(e,t){return this.getProof(e,t).map(e=>["left"===e.position?0:1,this.bufferToHex(e.data)])}getProofIndices(e,t){let r=2**t,a=new Set;for(let t of e){let e=r+t;for(;e>1;)a.add(1^e),e=e/2|0}let i=e.map(e=>r+e),s=Array.from(a).sort((e,t)=>e-t).reverse();a=i.concat(s);let n=new Set,l=[];for(let e of a)if(!n.has(e))for(l.push(e);e>1&&(n.add(e),n.has(1^e));)e=e/2|0;return l.filter(t=>!e.includes(t-r))}getProofIndicesForUnevenTree(e,t){let r=Math.ceil(Math.log2(t)),a=[];for(let e=0;e<r;e++)t%2!=0&&a.push({index:e,leavesCount:t}),t=Math.ceil(t/2);let i=[],s=e;for(let e=0;e<r;e++){let t=s.map(e=>e%2==0?e+1:e-1).filter(e=>!s.includes(e)),r=a.find(t=>{let{index:r}=t;return r===e});r&&s.includes(r.leavesCount-1)&&(t=t.slice(0,-1)),i.push(t),s=[...new Set(s.map(e=>e%2==0?e/2:e%2==0?(e+1)/2:(e-1)/2))]}return i}getMultiProof(e,t){if(this.complete||console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true"),t||(t=e,e=this.getLayersFlat()),this.isUnevenTree()&&t.every(Number.isInteger))return this.getMultiProofForUnevenTree(t);if(!t.every(Number.isInteger)){let e=t;this.sortPairs&&(e=e.sort(d.Buffer.compare));let r=e.map(e=>this.bufferIndexOf(this.leaves,e,this.sortLeaves)).sort((e,t)=>e===t?0:e>t?1:-1);if(!r.every(e=>-1!==e))throw Error("Element does not exist in Merkle tree");let a=[],i=[],s=[];for(let e=0;e<this.layers.length;e++){let t=this.layers[e];for(let e=0;e<r.length;e++){let n=r[e],l=this.getPairNode(t,n);a.push(t[n]),l&&i.push(l),s.push(n/2|0)}r=s.filter((e,t,r)=>r.indexOf(e)===t),s=[]}return i.filter(e=>!a.includes(e))}return this.getProofIndices(t,Math.log2(e.length/2|0)).map(t=>e[t])}getMultiProofForUnevenTree(e,t){t||(t=e,e=this.getLayers());let r=[],a=t;for(let t of e){let e=[];for(let r of a){if(r%2==0){let i=r+1;if(!a.includes(i)&&t[i]){e.push(t[i]);continue}}let i=r-1;if(!a.includes(i)&&t[i]){e.push(t[i]);continue}}r=r.concat(e);let i=new Set;for(let e of a){if(e%2==0){i.add(e/2);continue}if(e%2==0){i.add((e+1)/2);continue}i.add((e-1)/2)}a=Array.from(i)}return r}getHexMultiProof(e,t){return this.getMultiProof(e,t).map(e=>this.bufferToHex(e))}getProofFlags(e,t){let r;if(!Array.isArray(e)||e.length<=0)throw Error("Invalid Inputs!");if(!(r=e.every(Number.isInteger)?[...e].sort((e,t)=>e===t?0:e>t?1:-1):e.map(e=>this.bufferIndexOf(this.leaves,e,this.sortLeaves)).sort((e,t)=>e===t?0:e>t?1:-1)).every(e=>-1!==e))throw Error("Element does not exist in Merkle tree");let a=t.map(e=>this.bufferify(e)),i=[],s=[];for(let e=0;e<this.layers.length;e++){let t=this.layers[e];r=r.reduce((e,r)=>{if(!i.includes(t[r])){let e=this.getPairNode(t,r),n=a.includes(t[r])||a.includes(e);e&&s.push(!n),i.push(t[r]),i.push(e)}return e.push(r/2|0),e},[])}return s}verify(e,t,r){let a=this.bufferify(t);if(r=this.bufferify(r),!Array.isArray(e)||!t||!r)return!1;for(let t=0;t<e.length;t++){let r=e[t],i=null,s=null;if("string"==typeof r)i=this.bufferify(r),s=!0;else if(Array.isArray(r))s=0===r[0],i=this.bufferify(r[1]);else if(d.Buffer.isBuffer(r))i=r,s=!0;else if(r instanceof Object)i=this.bufferify(r.data),s="left"===r.position;else throw Error("Expected node to be of type string or object");let n=[];this.isBitcoinTree?(n.push(y()(a)),n[s?"unshift":"push"](y()(i)),a=this.hashFn(this.concatenator(n)),a=y()(this.hashFn(a))):(this.sortPairs?-1===d.Buffer.compare(a,i)?n.push(a,i):n.push(i,a):(n.push(a),n[s?"unshift":"push"](i)),a=this.hashFn(this.concatenator(n)))}return 0===d.Buffer.compare(a,r)}verifyMultiProof(e,t,r,a,i){if(this.isUnevenTree())return this.verifyMultiProofForUnevenTree(e,t,r,a,i);let s=Math.ceil(Math.log2(a));e=this.bufferify(e),r=r.map(e=>this.bufferify(e)),i=i.map(e=>this.bufferify(e));let n={};for(let[e,a]of this.zip(t,r))n[2**s+e]=a;for(let[e,r]of this.zip(this.getProofIndices(t,s),i))n[e]=r;let l=Object.keys(n).map(e=>Number(e)).sort((e,t)=>e-t);l=l.slice(0,l.length-1);let o=0;for(;o<l.length;){let e=l[o];if(e>=2&&({}).hasOwnProperty.call(n,1^e)){let t=[n[e-e%2],n[e-e%2+1]];this.sortPairs&&(t=t.sort(d.Buffer.compare));let r=t[1]?this.hashFn(this.concatenator(t)):t[0];n[e/2|0]=r,l.push(e/2|0)}o+=1}return!t.length||({}).hasOwnProperty.call(n,1)&&n[1].equals(e)}verifyMultiProofWithFlags(e,t,r,a){e=this.bufferify(e),t=t.map(this.bufferify),r=r.map(this.bufferify);let i=t.length,s=a.length,n=[],l=0,o=0,u=0;for(let e=0;e<s;e++){let s=[a[e]?l<i?t[l++]:n[o++]:r[u++],l<i?t[l++]:n[o++]].sort(d.Buffer.compare);n[e]=this.hashFn(this.concatenator(s))}return 0===d.Buffer.compare(n[s-1],e)}verifyMultiProofForUnevenTree(e,t,r,a,i){e=this.bufferify(e),r=r.map(e=>this.bufferify(e)),i=i.map(e=>this.bufferify(e));let s=this.calculateRootForUnevenTree(t,r,a,i);return e.equals(s)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){let e=this.getLayers().map(e=>e.map(e=>this.bufferToHex(e,!1))),t=[];for(let r=0;r<e.length;r++){let a=[];for(let i=0;i<e[r].length;i++){let s={[e[r][i]]:null};if(t.length){s[e[r][i]]={};let a=t.shift(),n=Object.keys(a)[0];if(s[e[r][i]][n]=a[n],t.length){let a=t.shift(),n=Object.keys(a)[0];s[e[r][i]][n]=a[n]}}a.push(s)}t.push(...a)}return t[0]}resetTree(){this.leaves=[],this.layers=[]}getPairNode(e,t){let r=t%2==0?t+1:t-1;return r<e.length?e[r]:null}toTreeString(){let e=this.getLayersAsObject();return(0,g.asTree)(e,!0,!1)}toString(){return this.toTreeString()}isUnevenTree(e){let t=e?.length||this.getDepth();return!this.isPowOf2(t)}isPowOf2(e){return e&&!(e&e-1)}calculateRootForUnevenTree(e,t,r,a){let i=this.zip(e,t).sort((e,t)=>{let[r]=e,[a]=t;return r-a}),s=i.map(e=>{let[t]=e;return t}),n=this.getProofIndicesForUnevenTree(s,r),l=0,o=[];for(let e=0;e<n.length;e++){let t=n[e],r=l;l+=t.length,o[e]=this.zip(t,a.slice(r,l))}let u=[i];for(let e=0;e<o.length;e++){let t=o[e].concat(u[e]).sort((e,t)=>{let[r]=e,[a]=t;return r-a}).map(e=>{let[,t]=e;return t}),r=[...new Set(u[e].map(e=>{let[t]=e;return t}).map(e=>e%2==0?e/2:e%2==0?(e+1)/2:(e-1)/2))],a=[];for(let e=0;e<r.length;e++){let i=r[e],s=t[2*e],n=t[2*e+1],l=n?this.hashFn(this.concatenator([s,n])):s;a.push([i,l])}u.push(a)}return u[u.length-1][0][1]}}var S=r(21187),T=r(14476),P=r(17152),k=r(42302),B=r(48287).Buffer;function C(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot,pricePerToken:e.pricePerToken,currency:e.currency,quantityLimitPerTransaction:e.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:e.waitTimeInSecondsBetweenClaims||0}}function A(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot,pricePerToken:e.pricePerToken,currency:e.currency,quantityLimitPerWallet:e.maxClaimablePerWallet,metadata:e.metadata||""}}function L(e,t){return"unlimited"===e?a.Is:i.parseUnits(e,t)}async function H(e){let t=Array.from({length:Math.ceil(e.length/25e3)},(t,r)=>e.slice(25e3*r,25e3*r+25e3)),r=[];for(let e of(await Promise.all(t.map(e=>h.bM.parseAsync(e)))))r.push(...e);return r}let I=function(e){return e[e.V1=1]="V1",e[e.V2=2]="V2",e}({});class z{constructor(e,t,r,a,i){this.storage=e,this.shardNybbles=a,this.baseUri=t,this.originalEntriesUri=r,this.tokenDecimals=i,this.shards={},this.trees={}}static async fromUri(e,t){try{let r=await t.downloadJSON(e);if(r.isShardedMerkleTree)return z.fromShardedMerkleTreeInfo(r,t)}catch(e){return}}static async fromShardedMerkleTreeInfo(e,t){return new z(t,e.baseUri,e.originalEntriesUri,e.shardNybbles,e.tokenDecimals)}static hashEntry(e,t,r,a){switch(a){case I.V1:return s.keccak256(["address","uint256"],[e.address,L(e.maxClaimable,t)]);case I.V2:return s.keccak256(["address","uint256","uint256","address"],[e.address,L(e.maxClaimable,t),L(e.price||"unlimited",r),e.currencyAddress||n.L])}}static async fetchAndCacheDecimals(e,t,r){if(!r)return 18;let a=e[r];return void 0===a&&(a=(await (0,c.f)(t,r)).decimals,e[r]=a),a}static async buildAndUpload(e,t,r,a,i){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2,n=await H(e),o={};for(let e of n){let t=e.address.slice(2,2+s).toLowerCase();void 0===o[t]&&(o[t]=[]),o[t].push(e)}let u={},f=Object.fromEntries(await Promise.all(Object.entries(o).map(async e=>{let[a,s]=e;return[a,new x(await Promise.all(s.map(async e=>{let a=await z.fetchAndCacheDecimals(u,r,e.currencyAddress);return z.hashEntry(e,t,a,i)})),l.keccak256,{sort:!0}).getHexRoot()]}))),h=new x(Object.values(f),l.keccak256,{sort:!0}),c=[];for(let[e,t]of Object.entries(o)){let r={proofs:h.getProof(f[e]).map(e=>"0x"+e.data.toString("hex")),entries:t};c.push({data:JSON.stringify(r),name:`${e}.json`})}let m=await a.uploadBatch(c),d=m[0].slice(0,m[0].lastIndexOf("/")),p=await a.upload(n),y={merkleRoot:h.getHexRoot(),baseUri:d,originalEntriesUri:p,shardNybbles:s,tokenDecimals:t,isShardedMerkleTree:!0},g=await a.upload(y);return{shardedMerkleInfo:y,uri:g}}async getProof(e,t,r){let a=e.slice(2,2+this.shardNybbles).toLowerCase(),i=this.shards[a],s={};if(void 0===i)try{let e=this.baseUri.endsWith("/")?this.baseUri:`${this.baseUri}/`;i=this.shards[a]=await this.storage.downloadJSON(`${e}${a}.json`);let n=await Promise.all(i.entries.map(async e=>{let a=await z.fetchAndCacheDecimals(s,t,e.currencyAddress);return z.hashEntry(e,this.tokenDecimals,a,r)}));this.trees[a]=new x(n,l.keccak256,{sort:!0})}catch(e){return null}let n=i.entries.find(t=>t.address.toLowerCase()===e.toLowerCase());if(!n)return null;let o=await z.fetchAndCacheDecimals(s,t,n.currencyAddress),u=z.hashEntry(n,this.tokenDecimals,o,r),f=this.trees[a].getProof(u).map(e=>"0x"+e.data.toString("hex"));return h.bN.parseAsync({...n,proof:f.concat(i.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(e){return console.warn("Could not fetch original snapshot entries",e),[]}}}async function N(e,t,r,a,i,s){if(!r)return null;let n=r[t];if(n){let r=await i.downloadJSON(n);if(r.isShardedMerkleTree&&r.merkleRoot===t){let t=await z.fromShardedMerkleTreeInfo(r,i);return await t.getProof(e,a,s)}let l=await h.bO.parseAsync(r);if(t===l.merkleRoot)return l.claims.find(t=>t.address.toLowerCase()===e.toLowerCase())||null}return null}function O(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot.toString(),pricePerToken:e.pricePerToken,currency:e.currency,maxClaimablePerWallet:e.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:e.waitTimeInSecondsBetweenClaims}}function E(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot.toString(),pricePerToken:e.pricePerToken,currency:e.currency,maxClaimablePerWallet:e.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:e.metadata}}async function M(e,t,a,s,n){let l=e.getSigner(),u=e.getProvider(),f=(await Promise.resolve().then(r.t.bind(r,96337,19))).default,c=new h.cs(l||u,t,f,e.options,e.storage),m=await e.getSignerAddress(),d=e.address,p=await c.read("allowance",[m,d]),y=o.gH.from(a).mul(o.gH.from(s)).div(i.parseUnits("1",n));p.lt(y)&&await c.sendTransaction("approve",[d,p.add(y)])}async function R(e,t,r,s,l,f,h,d,p){let y=L(r.maxClaimablePerWallet,l),g=[u.hexZeroPad([0],32)],b=r.price,w=r.currencyAddress;try{if(!r.merkleRootHash.toString().startsWith(n.L)){let t=await N(e,r.merkleRootHash.toString(),await s(),f.getProvider(),h,p);if(t)g=t.proof,y="unlimited"===t.maxClaimable?a.Is:i.parseUnits(t.maxClaimable,l),b=void 0===t.price||"unlimited"===t.price?a.Is:await (0,m.n)(f.getProvider(),t.price,t.currencyAddress||n.L),w=t.currencyAddress||n.L;else if(p===I.V1)throw Error("No claim found for this address")}}catch(e){if(e?.message==="No claim found for this address")throw e;console.warn("failed to check claim condition merkle root hash, continuing anyways",e)}let v=await f.getCallOverrides()||{},x=b.toString()!==a.Is.toString()?b:r.price,S=w!==n.L?w:r.currencyAddress;return x.gt(0)&&((0,c.i)(S)?v.value=o.gH.from(x).mul(t).div(i.parseUnits("1",l)):d&&await M(f,S,x,t,l)),{overrides:v,proofs:g,maxClaimable:y,price:x,currencyAddress:S,priceInProof:b,currencyAddressInProof:w}}let F=T.z.object({name:T.z.string(),symbol:T.z.string(),decimals:T.z.number()}).extend({value:h.b5,displayValue:T.z.string()}),U=T.z.object({name:T.z.string().optional()}).catchall(T.z.unknown()),D=T.z.object({startTime:S.S,currencyAddress:T.z.string().default(h.aV),price:h.cw.default(0),maxClaimableSupply:h.cA,maxClaimablePerWallet:h.cA,waitInSeconds:h.b6.default(0),merkleRootHash:h.cB.default(u.hexZeroPad([0],32)),snapshot:T.z.optional(h.bM).nullable(),metadata:U.optional()}),j=T.z.array(D),W=D.extend({availableSupply:h.cA,currentMintSupply:h.cA,currencyMetadata:F.default({value:o.gH.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:h.b5,waitInSeconds:h.b5,startTime:h.b5.transform(e=>new Date(1e3*e.toNumber())),snapshot:h.bM.optional().nullable()});async function q(e,t,r,a,i){let s=await H(e),n=s.map(e=>e.address);if(new Set(n).size<n.length)throw new h.s;let l=await z.buildAndUpload(s,t,r,a,i);return{merkleRoot:l.shardedMerkleInfo.merkleRoot,snapshotUri:l.uri}}async function V(e,t,r,a,i){let s=[];return{inputsWithSnapshots:await Promise.all(e.map(async e=>{if(e.snapshot&&e.snapshot.length>0){let n=await q(e.snapshot,t,r,a,i);s.push(n),e.merkleRootHash=n.merkleRoot}else e.merkleRootHash=u.hexZeroPad([0],32);return e})),snapshotInfos:s}}async function J(e,t,r,a){let i;let s=e.currencyAddress===n.L?h.aV:e.currencyAddress,l=L(e.maxClaimableSupply,t),o=L(e.maxClaimablePerWallet,t);return e.metadata&&(i="string"==typeof e.metadata?e.metadata:await a.upload(e.metadata)),{startTimestamp:e.startTime,maxClaimableSupply:l,supplyClaimed:0,maxClaimablePerWallet:o,pricePerToken:await (0,m.n)(r,e.price,s),currency:s,merkleRoot:e.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:e.waitInSeconds||0,metadata:i}}async function $(e,t,r,a,i){let{inputsWithSnapshots:s,snapshotInfos:n}=await V(e,t,r,a,i),l=await j.parseAsync(s);return{snapshotInfos:n,sortedConditions:(await Promise.all(l.map(e=>J(e,t,r,a)))).sort((e,t)=>(function(e,t){let r=o.gH.from(e),a=o.gH.from(t);return r.eq(a)?0:r.gt(a)?1:-1})(e.startTimestamp,t.startTimestamp))}}async function _(e,t,r){if(!t)return null;let a=t[e];if(a){let t=await r.downloadJSON(a);if(t.isShardedMerkleTree&&t.merkleRoot===e){let e=await z.fromUri(a,r);return e?.getAllEntries()||null}{let r=await h.bO.parseAsync(t);if(e===r.merkleRoot)return r.claims.map(e=>({address:e.address,maxClaimable:e.maxClaimable,price:e.price,currencyAddress:e.currencyAddress}))}}return null}function Z(e,t){return e.toString()===a.Is.toString()?"unlimited":i.formatUnits(e,t)}async function Y(e,t,r,a,i,s){let n;let l=await (0,c.a)(r,e.currency,e.pricePerToken),u=Z(e.maxClaimableSupply,t),f=Z(e.maxClaimablePerWallet,t),h=Z(o.gH.from(e.maxClaimableSupply).sub(e.supplyClaimed),t),m=Z(e.supplyClaimed,t);return e.metadata&&(n=await i.downloadJSON(e.metadata)),W.parseAsync({startTime:e.startTimestamp,maxClaimableSupply:u,maxClaimablePerWallet:f,currentMintSupply:m,availableSupply:h,waitInSeconds:e.waitTimeInSecondsBetweenClaims?.toString(),price:o.gH.from(e.pricePerToken),currency:e.currency,currencyAddress:e.currency,currencyMetadata:l,merkleRootHash:e.merkleRoot,snapshot:s?await _(e.merkleRoot,a,i):void 0,metadata:n})}async function K(e,t,r){if(e>=r.length)throw Error(`Index out of bounds - got index: ${e} with ${r.length} conditions`);let a=r[e].currencyMetadata.decimals,s=r[e].price,n=i.formatUnits(s,a),l=await D.parseAsync({...r[e],price:n,...t}),o=await W.parseAsync({...l,price:s});return r.map((t,r)=>{let s;s=r===e?o:t;let n=i.formatUnits(s.price,a);return{...s,price:n}})}let G=function(e){return e.NotEnoughSupply="There is not enough supply to claim.",e.AddressNotAllowed="This address is not on the allowlist.",e.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",e.ClaimPhaseNotStarted="Claim phase has not started yet.",e.AlreadyClaimed="You have already claimed the token.",e.WrongPriceOrCurrency="Incorrect price or currency.",e.OverMaxClaimablePerWallet="Cannot claim more than maximum allowed quantity.",e.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",e.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",e.NoClaimConditionSet="There is no claim condition set.",e.NoWallet="No wallet connected.",e.Unknown="No claim conditions found.",e}({});function Q(e){if(void 0!==e)return u.hexlify(e);{let e=B.alloc(16);return(0,k.A)({},e),u.hexlify(f.YW(e.toString("hex")))}}let X=T.z.object({to:h.b9.refine(e=>e.toLowerCase()!==n.L,{message:"Cannot create payload to mint to zero address"}),price:h.cw.default(0),currencyAddress:h.b8.default(h.aV),mintStartTime:S.S,mintEndTime:S.E,uid:T.z.string().optional().transform(e=>Q(e)),primarySaleRecipient:h.b9.default(n.L)}),ee=X.extend({quantity:h.cw}),et=ee.extend({mintStartTime:h.b5,mintEndTime:h.b5}),er=X.extend({metadata:P.N,royaltyRecipient:T.z.string().default(n.L),royaltyBps:h.cC.default(0)}),ea=er.extend({metadata:P.N.default(""),uri:T.z.string(),royaltyBps:h.b5,mintStartTime:h.b5,mintEndTime:h.b5}),ei=er.extend({metadata:P.N.default(""),quantity:h.b6}).extend({tokenId:h.b6}),es=ea.extend({tokenId:h.b5,quantity:h.b5}),en=er.extend({metadata:P.N.default(""),quantity:h.b5.default(1)}),el=ea.extend({quantity:h.b5.default(1)}),eo=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],eu=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],ef=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],eh=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}]},18924:(e,t,r)=>{var a=r(48287).Buffer;e.exports=function(e){for(var t=new a(e.length),r=0,i=e.length-1;r<=i;++r,--i)t[r]=e[i],t[i]=e[r];return t}},22539:function(e){var t;t=function(){function e(t,r,a,i,s,n,l){var o,u,f,h="",c=0,m=i.slice(0);if(m.push([r,a])&&i.length>0&&(i.forEach(function(e,t){t>0&&(h+=(e[1]?" ":"│")+"  "),f||e[0]!==r||(f=!0)}),h+=(o=a?"└":"├",t?o+="─ ":o+="──┐",o+t),s&&("object"!=typeof r||r instanceof Date)&&(h+=": "+r),f&&(h+=" (circular ref.)"),l(h)),!f&&"object"==typeof r){var d=function(e,t){var r=[];for(var a in e)e.hasOwnProperty(a)&&(!t||"function"!=typeof e[a])&&r.push(a);return r}(r,n);d.forEach(function(t){u=++c===d.length,e(t,r[t],u,m,s,n,l)})}}var t={};return t.asLines=function(t,r,a,i){e(".",t,!1,[],r,"function"!=typeof a&&a,i||a)},t.asTree=function(t,r,a){var i="";return e(".",t,!1,[],r,a,function(e){i+=e+"\n"}),i},t},e.exports=t()}}]);