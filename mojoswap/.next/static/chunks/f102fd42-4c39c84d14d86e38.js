"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[8210],{65765:(e,t,n)=>{let i;n.d(t,{a:()=>eh,b:()=>N,bB:()=>eb,bD:()=>eA,bE:()=>ef,bI:()=>eP,bK:()=>er,bL:()=>eo,bP:()=>eT,bR:()=>eS,bX:()=>eW,bY:()=>ek,bZ:()=>eE,bj:()=>ey,bk:()=>X,bl:()=>eC,bz:()=>eI,c:()=>_,d:()=>R,e:()=>D,f:()=>K,g:()=>$,h:()=>B,l:()=>j,o:()=>ep,q:()=>ew,s:()=>ev,u:()=>O,v:()=>em,y:()=>P}),n(71133);var a=n(96540),r=n(63064),o=n(59538),l=n(65697),s=n(59700),c=n(11561),u=n(74848),d=n(40257),h=n(17857),g=n(44930),f=n(91088),p=n(19337),w=n(50472),v=n(99473),m=n(48892),y=n(39549),C=n(8402),I=n(95979);n(17503);let b=(0,a.createContext)(void 0),A=(0,a.createContext)(void 0);function P(){return(0,a.useContext)(A)}let S=e=>{let t=e?.getOptions();return t&&"walletConnectReceiver"in t&&t.walletConnectReceiver},T="lastConnectedWallet",W=new Map,k=new Map,E=(0,a.createContext)(void 0);function x(e,t){let{chains:n,chainToConnect:r,dAppMeta:o,clientId:l,activeChain:s}=e,[c,u]=(0,a.useState)(void 0),[d,h]=(0,a.useState)(t.connectionStatus),[g,f]=(0,a.useState)(),[w,v]=(0,a.useState)(),[m,y]=(0,a.useState)(),[C,I]=(0,a.useState)(void 0),[b,A]=(0,a.useState)(void 0),P=(0,a.useMemo)(()=>({chains:n,dappMetadata:o,chain:s||n[0],clientId:l}),[n,o,s,l]),S=(0,a.useCallback)(e=>{let t=e.create(P);return t.walletId===p.w.magicLink&&v(t),W.set(t,e),t},[P]),E=(0,a.useCallback)(async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i=W.get(e);if(!i)throw Error("Wallet config not found for given wallet instance. Do not create a wallet instance manually - use the useCreateWalletInstance() hook instead");let[a,r,o]=await Promise.all([e.getSigner(),e.getChainId(),e.getAddress()]);f(e),I(r),A(o),u(a),y(i),h("connected");let l=e.getPersonalWallet();if(k.set(l,e),n)return;let s={walletId:i.id,connectParams:t||e.getConnectParams()},c=W.get(l);l&&c&&(s.connectParams={...s.connectParams,personalWallet:{walletId:c.id,connectParams:l.getConnectParams()}}),U(s)},[]),x=(0,a.useCallback)(async e=>{let t=await i.getItem(T);if(t)try{let n=JSON.parse(t);n.connectParams?n.connectParams.chainId=e:n.connectParams={chainId:e},await i.setItem(T,JSON.stringify(n))}catch(e){console.error(`Error saving the last active chain: ${e}`)}},[]),L=(0,a.useCallback)(async e=>{if(!g)throw Error("No active wallet");await g.switchChain(e);let t=await g.getSigner();await x(e),u(t)},[g,x]),j=(0,a.useCallback)(async function(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];let[i,a]=t,o={chainId:r?.chainId,...a||{}},l=S(i);h("connecting");try{i.id===p.w.magicLink&&U({walletId:i.id,connectParams:o}),await l.connect(o),E(l,o)}catch(e){throw console.error(`Error connecting to wallet: ${e}`),h("disconnected"),e}return l},[S,E,r]),M=(0,a.useCallback)(()=>{h("disconnected"),u(void 0),f(void 0),y(void 0),I(void 0),A(void 0),i.removeItem(T)},[]),q=(0,a.useCallback)(async()=>{if(!g){M();return}M();let e=g.getPersonalWallet();await g.disconnect(),e&&await e?.disconnect()},[g,M]);return(0,a.useEffect)(()=>{if(!g){u(void 0),I(void 0),A(void 0);return}let e=async()=>{Promise.all([g.getSigner(),g.getChainId(),g.getAddress()]).then(e=>{let[t,n,i]=e;u(t),I(n),A(i)})};return e(),g.addListener("change",e),g.addListener("disconnect",M),()=>{g.removeListener("change",e),g.removeListener("disconnect",M)}},[g,M]),(0,a.useEffect)(()=>{g&&g.updateChains(n)},[g,n]),{signer:c,connectionStatus:d,setConnectionStatus:h,activeWallet:g,createdWalletInstance:w,activeWalletConfig:m,createWalletInstance:S,setConnectedWallet:E,switchChain:L,connectWallet:j,disconnectWallet:q,chainId:C,address:b}}function L(e){let t=e.autoSwitch?e.activeChain:void 0,n=e.autoConnectTimeout||15e3,r={chains:e.chains,dAppMeta:e.dAppMeta,activeChain:e.activeChain,clientId:e.clientId,chainToConnect:t},{signer:o,connectionStatus:l,setConnectionStatus:s,activeWallet:c,createdWalletInstance:d,activeWalletConfig:h,createWalletInstance:g,setConnectedWallet:f,switchChain:v,connectWallet:m,disconnectWallet:y,address:C,chainId:I}=x(r,{connectionStatus:"unknown"}),b=x(r,{connectionStatus:"disconnected"}),[A,P]=(0,a.useState)(!1),[L,j]=(0,a.useState)();i||(i=e.createWalletStorage("coordinatorStorage")),(0,a.useEffect)(()=>{if(!c)return;let e=async()=>{let e=c?.getOptions(),t=new w.c2({walletConnectReceiver:{...e?.walletConnectReceiver===!0?{}:e?.walletConnectReceiver}},c);await t.init(),j(t)};S(c)&&e()},[c]);let U=(0,a.useRef)(!1);(0,a.useEffect)(()=>{if(!U.current&&(U.current=!0,!e.signerWallet&&!c&&"unknown"===l)){if(!1===e.shouldAutoConnect){s("disconnected");return}!async function(){let t;let a=await M();if(!a){s("disconnected");return}let r=e.supportedWallets.find(e=>e.id===a.walletId);if(!r){s("disconnected");return}let o=a.connectParams?.personalWallet,l=!1;r.personalWallets&&!o&&(l=a.walletId!==p.w.magicLink||!a.connectParams||!("oauthProvider"in a.connectParams),o={walletId:a.walletId,connectParams:a.connectParams});let c=o;if(c){let e=(r.personalWallets||[]).find(e=>e.id===c.walletId);if(e){t=g(e);try{await q(t.autoConnect(c.connectParams),{ms:n,message:F}),l&&f(t,c.connectParams,!0)}catch(e){console.error("Failed to auto connect personal wallet"),console.error(e),s("disconnected");return}a.connectParams={...a.connectParams,personalWallet:t}}else{s("disconnected");return}}let u=g(r);try{P(!0),s("connecting"),t&&k.set(t,u),await q(u.autoConnect(a.connectParams),{ms:n,message:F}),l||f(u,a.connectParams,!0)}catch(e){console.error("Failed to auto connect wallet"),console.error(e),e instanceof Error&&e.message===F&&i.removeItem(T),s("disconnected")}P(!1)}()}},[g,e.supportedWallets,f,e.shouldAutoConnect,c,l,e.signerWallet,s,n]);let O=(0,a.useRef)();return(0,a.useEffect)(()=>{if(!e.signerWallet){O.current&&(y(),O.current=void 0);return}O.current!==e.signerWallet&&(f(g(e.signerWallet)),O.current=e.signerWallet)},[g,e.supportedWallets,f,e.signerWallet,y]),(0,u.jsx)(E.Provider,{value:{address:C,chainId:I,disconnect:y,wallets:e.supportedWallets,connect:m,signer:o,activeWallet:c,activeWalletConfig:h,connectionStatus:l,setConnectionStatus:s,createWalletInstance:g,createdWalletInstance:d,createWalletStorage:e.createWalletStorage,switchChain:v,setConnectedWallet:f,activeChain:e.activeChain,chainToConnect:t,getWalletConfig:e=>W.get(e),getWrapperWallet:e=>k.get(e),activeChainSetExplicitly:e.activeChainSetExplicitly,clientId:e.clientId,walletConnectHandler:L,personalWalletConnection:b,isAutoConnecting:A},children:e.children})}function j(){let e=(0,a.useContext)(E);if(!e)throw Error("useWalletContext() can only be used inside <ThirdwebProvider />");return e}async function M(){let e=await i.getItem(T);if(!e)return null;try{return JSON.parse(e)}catch{return await i.removeItem(T),null}}async function U(e){try{await i.setItem(T,JSON.stringify(e))}catch(e){console.error("Error saving the last connected wallet info",e)}}function q(e,t){return new Promise((n,i)=>{let a=setTimeout(()=>{i(Error(t.message))},t.ms);e.then(e=>{clearTimeout(a),n(e)},e=>{clearTimeout(a),i(e)})})}let F="Failed to Auto connect. Auto connect timed out. You can increase the timeout duration using the autoConnectTimeout prop on <ThirdwebProvider />";function O(e){let t=j();(0,c.A)(t,"useWallet() hook must be used within a <ThirdwebProvider/>");let n=t.activeWallet;if(n&&(!e||n.walletId===e))return n}function B(){let e=j();return(0,c.A)(e,"useWallet() hook must be used within a <ThirdwebProvider/>"),e.activeWalletConfig}function $(){let e=j();return(0,c.A)(e,"useWallets() hook must be used within a <ThirdwebProvider/>"),e.wallets}function N(){let e=j();return(0,c.A)(e,"useConnect() hook must be used within a <ThirdwebProvider/>"),e.connect}function D(){let e=j();return(0,c.A)(e,"useDisconnect() hook must be used within a <ThirdwebProvider/>"),e.disconnect}function _(){let e=j();return(0,c.A)(e,"useConnectionStatus() must be used within a <ThirdwebProvider/>"),e.connectionStatus}function R(){let e=j();return(0,c.A)(e,"useCreateWalletInstance() must be used within a <ThirdwebProvider/>"),e.createWalletInstance}function K(){let e=j();return(0,c.A)(e,"useSwitchChain() must be used within a <ThirdwebProvider/>"),e.switchChain}let Y="auth_token_storage_key",J="tw-cache";function V(e){return[J,...e.filter(e=>"string"!=typeof e||e!==J)]}function H(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:m.L,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return V(["contract",e,...t])}function Q(e,t){return V(z.network.active(t).concat(e))}let z={auth:{user:()=>V(["user"])},network:{active:e=>V(["chainId",e])},wallet:{balance:(e,t,n)=>V(Q(V(["balance",{walletAddress:t,tokenAddress:n}]),e))},contract:{read:(e,t)=>H(e,["read",t]),type:e=>H(e,["contract-type"]),compilerMetadata:e=>H(e,["publish-metadata"]),typeAndCompilerMetadata:e=>H(e,["contract-type-and-metadata"]),metadata:e=>H(e,["metadata"]),extractFunctions:e=>H(e,["extractFunctions"]),call:(e,t,n,i)=>H(e,["call",t,n,i]),accountFactory:{getAll:e=>H(e,["accountFactory"]),isAccountDeployed:(e,t)=>H(e,["isAccountDeployed",t]),getAllForAddress:(e,t)=>H(e,["getAllForAddress",t])},account:{signers:e=>H(e,["account","signers"])},app:{get:e=>H(e,["appURI"])},events:{getEvents:(e,t)=>H(e,["events","getEvents",{eventName:t}]),getAllEvents:e=>H(e,["events","getAllEvents"])},nft:{get:(e,t)=>H(e,["get",{tokenId:t}]),balanceOf:(e,t,n)=>H(e,["balanceOf",{owner:t,tokenId:n}]),query:{all:(e,t)=>H(e,t?["query","all",t]:["query","all"]),totalCirculatingSupply:(e,t)=>H(e,["query","totalCirculatingSupply",t??"0"]),totalCount:e=>H(e,["query","totalCount"]),owned:{all:(e,t)=>H(e,["query","owned","all",t])}},sharedMetadata:{get:e=>H(e)},drop:{getAllUnclaimed:(e,t)=>H(e,t?["getAllUnclaimed",t]:["getAllUnclaimed"]),getAllClaimed:(e,t)=>H(e,t?["getAllClaimed",t]:["getAllClaimed"]),totalUnclaimedSupply:e=>H(e,["totalUnclaimedSupply"]),totalClaimedSupply:e=>H(e,["totalClaimedSupply"]),revealer:{getBatchesToReveal:(e,t)=>H(e,t?["getBatchesToReveal",t]:["getBatchesToReveal"])}}},token:{totalSupply:e=>H(e,["totalSupply"]),decimals:e=>H(e,["decimals"]),balanceOf:(e,t)=>H(e,["balanceOf",{walletAddress:t}])},marketplace:{getListing:(e,t)=>H(e,["getListing",{listingId:t}]),getAllListings:(e,t)=>H(e,t?["getAllListings",t]:["getAllListings"]),getTotalCount:e=>H(e,["getTotalCount"]),getActiveListings:(e,t)=>H(e,t?["getActiveListings",t]:["getActiveListings"]),auction:{getBidBufferBps:(e,t)=>H(e,["auction","getBidBufferBps",{listingId:t}]),getWinningBid:(e,t)=>H(e,["auction","getWinningBid",{listingId:t}]),getMinimumNextBid:(e,t)=>H(e,["auction","getMinimumNextBid",{listingId:t}]),getWinner:(e,t)=>H(e,["auction","getWinner",{listingId:t}])},directListings:{getAll:(e,t)=>H(e,t?["directListings","getAll",t]:["directListings","getAll"]),getAllValid:(e,t)=>H(e,t?["directListings","getAllValid",t]:["directListings","getAllValid"]),getListing:(e,t)=>H(e,["directListings","getListing",{listingId:t}]),getTotalCount:e=>H(e,["directListings","getTotalCount"])},englishAuctions:{getAll:(e,t)=>H(e,t?["englishAuctions","getAll",t]:["englishAuctions","getAll"]),getAllValid:(e,t)=>H(e,t?["englishAuctions","getAllValid",t]:["englishAuctions","getAllValid"]),getAuction:(e,t)=>H(e,["englishAuctions","getAuction",{auctionId:t}]),getWinningBid:(e,t)=>H(e,["englishAuctions","getWinningBid",{auctionId:t}]),getTotalCount:e=>H(e,["englishAuctions","getTotalCount"])}}}};function X(){let e=(0,r.jE)(),t=P(),n=(0,o.n)({mutationFn:async()=>{(0,c.A)(t,"Please specify an authConfig in the ThirdwebProvider"),(0,c.A)(t.authUrl,"Please specify an authUrl in the authConfig."),await fetch(`${t.authUrl}/logout`,{method:"POST",credentials:"include"}),t.secureStorage?.removeItem(Y),e.invalidateQueries(z.auth.user())}});return{logout:n.mutateAsync,isLoading:n.isLoading}}let Z=e=>{let{value:t,children:n}=e,i=(0,a.useMemo)(()=>{if(t)return{...t,authUrl:t.authUrl?.replace(/\/$/,"")}},[t]);return(0,u.jsxs)(A.Provider,{value:i,children:[n,(0,u.jsx)(G,{})]})};function G(){let e=O(),{logout:t}=X(),{switchAccount:n}=function(){let e=(0,r.jE)(),t=P(),n=(0,o.n)({mutationFn:async n=>{(0,c.A)(t,"Please specify an authConfig in the ThirdwebProvider"),(0,c.A)(t.authUrl,"Please specify an authUrl in the authConfig."),await fetch(`${t.authUrl}/switch-account`,{method:"POST",credentials:"include",headers:{"Content-Type":"application/json"},body:JSON.stringify({address:n})}),e.invalidateQueries(z.auth.user())}});return{switchAccount:n.mutateAsync,isLoading:n.isLoading}}(),i=P(),l=(0,r.jE)();return(0,a.useEffect)(()=>{let a=async e=>{if(e.address)try{await n(e.address)}catch(t){console.debug(`[Auth] Failed to switch account to ${e.address} with error:
`,t)}},r=async()=>{try{await t()}catch(e){console.debug(`[Auth] Failed to logout with error:
`,e)}},o=!!e&&i&&i.authUrl;return o&&(e.addListener("connect",a),e.addListener("change",a),e.addListener("disconnect",r)),()=>{o&&(e.removeListener("connect",a),e.removeListener("change",a),e.removeListener("disconnect",r))}},[e,l,i,t,n]),null}function ee(e,t,n){return[(0,a.useMemo)(()=>e.map(e=>(0,d.NyD)(e,n)),[e,n]),(0,a.useMemo)(()=>t&&"string"!=typeof t&&"number"!=typeof t?(0,d.NyD)(t,n):t,[t,n])]}let et=e=>{let{queryClient:t,children:n}=e,i=(0,a.useMemo)(()=>t||new l.E,[t]);return(0,u.jsx)(r.Ht,{client:i,children:n})},en=(0,a.createContext)(void 0),ei=e=>{let{value:t,children:n}=e;return(0,u.jsx)(en.Provider,{value:t,children:n})},ea=(0,a.createContext)({});function er(){let{sdk:e}=function(){let e=(0,a.useContext)(ea);return(0,c.A)(e._inProvider,"useSDK must be called from within a ThirdwebProvider, did you forget to wrap your app in a <ThirdwebProvider />?"),e}();return e}function eo(){let e=er();return e?._chainId}let el={wallet:void 0,address:void 0,chainId:void 0,signer:void 0},es=(0,a.createContext)(void 0),ec=e=>{let{signer:t,children:n}=e,{chains:i,clientId:r}=function(){let e=(0,a.useContext)(en);return(0,c.A)(e,"useThirdwebConfigContext() hook must be used within a <ThirdwebProvider/>"),e}(),o=er()?.storage,[l,s]=(0,a.useState)({...el,signer:t||void 0});return(0,a.useEffect)(()=>{s(e=>({...e,signer:t||void 0}))},[t]),(0,a.useEffect)(()=>{if(!o)return;let e=t;return t?Promise.all([t.getAddress(),t.getChainId()]).then(n=>{let a,[l,c]=n,u=i.find(e=>e.chainId===c);if(u)try{a=(0,d.aSY)(u,r)[0]}catch(e){console.error(e)}t===e&&s({wallet:new g.U(t,{readonlySettings:a?{rpcUrl:a,chainId:c}:void 0},o),address:l,chainId:c,signer:t})}).catch(e=>{}):s(el),()=>{e=void 0}},[t,r]),(0,u.jsx)(es.Provider,{value:l,children:n})},eu=e=>{let{sdkOptions:t={},storageInterface:n,supportedChains:i,activeChain:r,signer:o,children:l,clientId:s,secretKey:c}=e,g=(0,a.useMemo)(()=>r?"number"==typeof r?r:"string"==typeof r?i.find(e=>e.slug===r)?.chainId:r.chainId:i[0]?.chainId,[r,i]),f=(0,a.useMemo)(()=>{let e,a,r=g,o=i.find(e=>e.chainId===r);if(o||void 0===r||(console.warn(`The chainId ${r} is not in the configured chains, please add it to the ThirdwebProvider`),r=void 0),o&&o.rpc.length>0)try{let t=(0,d.aSY)(o,s)[0];e={chainId:o.chainId,rpcUrl:t}}catch(e){}let l={readonlySettings:e,...t,supportedChains:i};if(r&&(a=new h.gvY(r,{...l,clientId:s,secretKey:c},n)),!a){if(i.length>0)r=i[0].chainId,a=new h.gvY(r,l,n);else{console.error("No chains configured, please pass a chain or chains to the ThirdwebProvider");return}}return a._chainId=r,a},[g,i,t,n,s,c]);(0,a.useEffect)(()=>{f&&f._chainId===g&&(o?f.updateSignerOrProvider(o):g&&f.updateSignerOrProvider(g))},[f,f?._chainId,o,g]);let p=(0,a.useMemo)(()=>({sdk:f&&f._chainId===g?f:void 0,_inProvider:!0}),[g,f]);return(0,u.jsx)(ea.Provider,{value:p,children:l})},ed=e=>{let{signer:t,children:n,queryClient:i,supportedChains:r,activeChain:o,clientId:l,...s}=e;l||(0,g.c)("No API key. Please provide a clientId. It is required to access thirdweb's services. You can create a key at https://thirdweb.com/create-api-key",l,void 0);let c=r||d.k9b,h=(0,a.useMemo)(()=>"object"==typeof o&&null!==o?c.find(e=>e.chainId===o.chainId)?c.map(e=>e.chainId===o.chainId?o:e):[...c,o]:c,[c,o]),[f,p]=ee(h,o||h[0],l),w=(0,a.useMemo)(()=>p&&"string"!=typeof p&&"number"!=typeof p?[...f.filter(e=>e.chainId!==p.chainId),p].filter((e,t,n)=>t===n.findIndex(t=>t.chainId===e.chainId)):f,[f,p]);return(0,u.jsx)(ei,{value:{chains:w,clientId:l},children:(0,u.jsx)(et,{queryClient:i,children:(0,u.jsx)(eu,{signer:t,supportedChains:w,clientId:l,activeChain:p,...s,children:(0,u.jsx)(ec,{signer:t,children:n})})})})},eh=e=>{let{activeChain:t,createWalletStorage:n=v.c}=e,i=e.supportedChains||d.k9b,r=(0,a.useMemo)(()=>"object"==typeof t&&null!==t?i.find(e=>e.chainId===t.chainId)?i.map(e=>e.chainId===t.chainId?t:e):[...i,t]:i,[i,t]),[o,l]=ee(r,e.activeChain||r[0],e.clientId),s=(0,a.useMemo)(()=>{if("number"==typeof l){let e=o.find(e=>e.chainId===l);if(!e)throw Error(`Invalid chainId: ${l}. It is not one of supportedChains`);return e}if("string"==typeof l){let e=o.find(e=>e.slug===l);if(!e)throw Error(`Invalid chain: "${l}". It is not one of supportedChains`);return e}return l},[l,o]),c=e.dAppMeta;return(0,u.jsx)(b.Provider,{value:e.theme,children:(0,u.jsx)(L,{chains:o,supportedWallets:e.supportedWallets,shouldAutoConnect:e.autoConnect,createWalletStorage:n,dAppMeta:c,activeChain:s,autoSwitch:e.autoSwitch,autoConnectTimeout:e.autoConnectTimeout,clientId:e.clientId,activeChainSetExplicitly:!!e.activeChain,signerWallet:e.signerWallet,children:(0,u.jsx)(eg,{queryClient:e.queryClient,sdkOptions:e.sdkOptions,supportedChains:o,activeChain:s,storageInterface:e.storageInterface,authConfig:e.authConfig,clientId:e.clientId,secretKey:e.secretKey,children:(0,u.jsx)(Z,{value:e.authConfig,children:e.children})})})})},eg=e=>{let{children:t,...n}=e,i=j()?.signer;return(0,u.jsx)(ed,{signer:i,...n,children:t})};function ef(){let e=(0,a.useContext)(en);return(0,c.A)(e,"useSupportedChains() hook must be used within a <ThirdwebProvider/>"),e.chains}function ep(e){let t=ew(),{wallet:n,address:i,chainId:r}=function(){let e=(0,a.useContext)(es);return(0,c.A)(e,"useThirdwebConnectedWalletContext() hook must be used within a <ThirdwebProvider/>"),e}(),o=(0,a.useMemo)(()=>z.wallet.balance(r||-1,i,e),[r,e,i]);return(0,s.I)(o,()=>n?.balance(e),{enabled:!!n&&!!t&&!!r,retry:!0,keepPreviousData:!1})}function ew(){let e=(0,a.useContext)(es),t=(0,a.useContext)(E);return t?t.address:((0,c.A)(e,"useAddress() hook must be used within a <ThirdwebProvider/>"),e.address)}function ev(){let e=(0,a.useContext)(es),t=(0,a.useContext)(E);return t?t.chainId:((0,c.A)(e,"useChainId() hook must be used within a <ThirdwebProvider/> or <ThirdwebSDKProvider/> component"),e.chainId)}function em(){let e=ev(),t=ef(),n=(0,a.useMemo)(()=>t.find(t=>t.chainId===e),[e,t]),i=(0,a.useMemo)(()=>{if(!n)return d.k9b.find(t=>t.chainId===e)},[e,n]);return n||i}function ey(){let e=(0,r.jE)(),t=P(),n=O(),i=(0,o.n)({mutationFn:async()=>{let i;(0,c.A)(t,"Please specify an authConfig in the ThirdwebProvider"),(0,c.A)(n,"You need a connected wallet to login."),(0,c.A)(t.authUrl,"Please specify an authUrl in the authConfig.");let a=await n.getAddress(),r=await n.getChainId(),o=await fetch(`${t.authUrl}/payload`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({address:a,chainId:r.toString()})});if(!o.ok)throw Error(`Failed to get payload with status code ${o.status}`);try{({payload:i}=await o.json())}catch{throw Error("Failed to get payload")}let l=await (0,I.s)({wallet:n,payload:i});if(!(o=await fetch(`${t.authUrl}/login`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({payload:l}),credentials:"include"})).ok){let e=await o.json();if(e.error)throw Error(e.error);throw Error(`Login request failed with status code ${o.status}`)}let{token:s}=await o.json();return await t.secureStorage?.setItem(Y,s),e.invalidateQueries(z.auth.user()),s}});return{login:()=>i.mutateAsync(),isLoading:i.isLoading}}function eC(){let e=P(),{data:t,isLoading:n}=(0,s.I)(z.auth.user(),async()=>{(0,c.A)(e,"Please specify an authConfig in the ThirdwebProvider"),(0,c.A)(e.authUrl,"Please specify an authUrl in the authConfig.");let t=await e.secureStorage?.getItem(Y),n={credentials:"include",...t?{headers:{Authorization:`Bearer ${t}`}}:{}},i=await fetch(`${e.authUrl}/user`,n);return await i.json()},{enabled:!!e});return{user:t,isLoggedIn:!!t,isLoading:n}}function eI(){let e=er();return e?.storage}function eb(){let e=ev(),t=eo();return!!t&&-1!==t&&!!e&&t!==e}function eA(){let e=(0,a.useContext)(es),t=(0,a.useContext)(E);return t?t.signer:((0,c.A)(e,"useSigner() hook must be used within a <ThirdwebProvider/> or <ThirdwebSDKProvider/> component"),e.signer)}function eP(){let e=ew(),t=ef(),{clientId:n}=j(),i=t.find(e=>1===e.chainId);return(0,s.I)({queryKey:["ens",e,i?.rpc],cacheTime:864e5,staleTime:36e5,retry:!1,enabled:!!e,queryFn:async()=>{if(!e)return null;let t=(0,h.VAK)(1,{clientId:n,supportedChains:i?[{chainId:1,rpc:[...i.rpc],nativeCurrency:i.nativeCurrency,slug:i.slug}]:void 0});if(t instanceof y.F){let[n,i]=await Promise.all([t.lookupAddress(e),t.getAvatar(e)]);return{ens:n,avatarUrl:i}}return{ens:await t.lookupAddress(e),avatarUrl:null}}})}function eS(e){let t=!(arguments.length>1)||void 0===arguments[1]||arguments[1];return`${e.substring(0,t?4:6)}...${e.substring(e.length-(t?3:4))}`}function eT(e){let t=!(arguments.length>1)||void 0===arguments[1]||arguments[1];if(!e)return"";try{let n=C.getAddress(e);return eS(n,t)}catch{return e}}function eW(e,t){return(0,s.I)({...t,queryKey:["buyWithCryptoHistory",e],queryFn:()=>{if(!e)throw Error("Swap params are required");return(0,f.b)(e)},enabled:!!e})}function ek(e,t){return(0,s.I)({...t,queryKey:["buyWithCryptoQuote",e],queryFn:()=>{if(!e)throw Error("Swap params are required");if(!e?.clientId)throw Error("Client ID is required in swap params");return(0,f.c)(e)},enabled:!!e})}function eE(e){let[t,n]=(0,a.useState)(5e3);return(0,s.I)({queryKey:["swapStatus",e?.transactionHash],queryFn:async()=>{if(!e)throw Error("Missing swap status params");if(!e?.clientId)throw Error("Missing clientId in swap status params");let t=await (0,f.d)({...e,clientId:e.clientId});return("COMPLETED"===t.status||"FAILED"===t.status)&&n(0),t},enabled:!!e,refetchInterval:t,refetchIntervalInBackground:!0,retry:!0})}}}]);