"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6048],{7471:(t,a,e)=>{e.d(a,{D:()=>g,F:()=>l,I:()=>c,a:()=>p,b:()=>f,c:()=>h,f:()=>d,g:()=>y,u:()=>u});var r=e(17152),n=e(8471),s=e(37457),o=e(86863),i=e(48287).Buffer;let c=n.arrayify("0x80ac58cd"),p=n.arrayify("0xd9b67a26"),l={name:"Failed to load NFT metadata"};async function d(t,a,e){let o;if(a.startsWith("data:application/json;base64")&&void 0!==i){let e=a.split(",")[1],n=JSON.parse(i.from(e,"base64").toString("utf-8"));return r.a.parse({...n,id:s.gH.from(t).toString(),uri:a})}let c=a.replace("{id}",n.hexZeroPad(s.gH.from(t).toHexString(),32).slice(2));try{o=await e.downloadJSON(c)}catch(n){let r=a.replace("{id}",s.gH.from(t).toString());try{o=await e.downloadJSON(r)}catch(e){console.warn(`failed to get token metadata: ${JSON.stringify({tokenId:t.toString(),tokenUri:a})} -- falling back to default metadata`),o=l}}return r.a.parse({...o,id:s.gH.from(t).toString(),uri:a})}async function h(t,a,n,i){let h;let f=(await e.e(4811).then(e.t.bind(e,94811,19))).default,u=new o.NZ(t,f,a),[y,g]=await Promise.all([u.supportsInterface(c),u.supportsInterface(p)]);if(y){let r=(await Promise.resolve().then(e.t.bind(e,1024,19))).default,s=new o.NZ(t,r,a);h=await s.tokenURI(n)}else if(g){let r=(await Promise.resolve().then(e.t.bind(e,51146,19))).default,s=new o.NZ(t,r,a);h=await s.uri(n)}else throw Error("Contract must implement ERC 1155 or ERC 721.");return h?d(n,h,i):r.a.parse({...l,id:s.gH.from(n).toString(),uri:""})}async function f(t,a){return"string"==typeof t?t:await a.upload(r.C.parse(t))}async function u(t,a,e,n){if(void 0===t.find(t=>"string"!=typeof t))return t;if(void 0===t.find(t=>"object"!=typeof t))return await a.uploadBatch(t.map(t=>r.C.parse(t)),{rewriteFileNames:{fileStartNumber:e||0},onProgress:n?.onProgress});throw Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)")}function y(t){let a=t[0].substring(0,t[0].lastIndexOf("/"));for(let e=0;e<t.length;e++){let r=t[e].substring(0,t[e].lastIndexOf("/"));if(a!==r)throw Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${a}' but got '${r}'`)}return a.replace(/\/$/,"")+"/"}let g=100},66048:(t,a,e)=>{e.d(a,{C:()=>w,D:()=>m,a:()=>I,c:()=>W});var r=e(12204),n=e(79195),s=e(27454),o=e(95848),i=e(71414),c=e(47197),p=e(57127),l=e(8471),d=e(37457),h=e(86863),f=e(17152),u=e(7471),y=e(73207),g=e(29966);class w{featureName=s.d5.name;constructor(t,a){this.contractWrapper=t,this.metadata=a}async getDefaultRoyaltyInfo(){let[t,a]=await this.contractWrapper.read("getDefaultRoyaltyInfo",[]);return s.bF.parseAsync({fee_recipient:t,seller_fee_basis_points:a})}async getTokenRoyaltyInfo(t){let[a,e]=await this.contractWrapper.read("getRoyaltyInfoForToken",[t]);return s.bF.parseAsync({fee_recipient:a,seller_fee_basis_points:e})}setDefaultRoyaltyInfo=(0,n.f)(async t=>{let a=await this.metadata.get(),e=await this.metadata.parseInputMetadata({...a,...t}),s=await this.metadata._parseAndUploadMetadata(e);if((0,r.h)("setContractURI",this.contractWrapper)){let t=new o.C(this.contractWrapper),a=[t.encode("setDefaultRoyaltyInfo",[e.fee_recipient,e.seller_fee_basis_points]),t.encode("setContractURI",[s])];return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[a],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}throw Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.")});setTokenRoyaltyInfo=(0,n.f)(async(t,a)=>{let e=s.bF.parse(a);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setRoyaltyInfoForToken",args:[t,e.fee_recipient,e.seller_fee_basis_points],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})})}class m{constructor(t,a,e,r){this.featureName=e,this.nextTokenIdToMintFn=r,this.contractWrapper=t,this.storage=a}createDelayedRevealBatch=(0,n.f)(async(t,a,e,r)=>{let s;if(!e)throw Error("Password is required");let o=await this.storage.uploadBatch([f.C.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),l=(0,u.g)(o),d=await this.nextTokenIdToMintFn(),h=await this.storage.uploadBatch(a.map(t=>f.C.parse(t)),{onProgress:r?.onProgress,rewriteFileNames:{fileStartNumber:d.toNumber()}}),y=(0,u.g)(h),g=await this.contractWrapper.read("getBaseURICount",[]),w=await this.hashDelayRevealPassword(g,e),m=await this.contractWrapper.read("encryptDecrypt",[i.YW(y),w]);if(await this.isLegacyContract())s=m;else{let t=await this.contractWrapper.getChainID(),a=c.keccak256(["bytes","bytes","uint256"],[i.YW(y),w,t]);s=p.D.encode(["bytes","bytes32"],[m,a])}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[h.length,l.endsWith("/")?l:`${l}/`,s],parse:t=>{let a=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),e=a[0].args.startTokenId,r=a[0].args.endTokenId,n=[];for(let a=e;a.lte(r);a=a.add(1))n.push({id:a,receipt:t});return n}})});reveal=(0,n.f)(async(t,a)=>{if(!a)throw Error("Password is required");let e=await this.hashDelayRevealPassword(t,a);try{let a=await this.contractWrapper.callStatic().reveal(t,e);if(!a.includes("://")||!a.endsWith("/"))throw Error("invalid password")}catch(t){throw Error("invalid password")}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,e]})});async getBatchesToReveal(){let t=await this.contractWrapper.read("getBaseURICount",[]);if(t.isZero())return[];let a=Array.from(Array(t.toNumber()).keys()),e=await Promise.all(a.map(t=>{if((0,r.h)("getBatchIdAtIndex",this.contractWrapper))return this.contractWrapper.read("getBatchIdAtIndex",[t]);if((0,r.h)("baseURIIndices",this.contractWrapper))return this.contractWrapper.read("baseURIIndices",[t]);throw Error("Contract does not have getBatchIdAtIndex or baseURIIndices.")})),n=e.slice(0,e.length-1),s=await Promise.all(Array.from([0,...n]).map(t=>this.getNftMetadata(t.toString()))),o=await this.isLegacyContract(),i=(await Promise.all(Array.from([...e]).map(t=>o?this.getLegacyEncryptedData(t):this.contractWrapper.read("encryptedData",[t])))).map(t=>l.hexDataLength(t)>0?o?t:p.D.decode(["bytes","bytes32"],t)[0]:t);return s.map((t,a)=>({batchId:d.gH.from(a),batchUri:t.uri,placeholderMetadata:t})).filter((t,a)=>l.hexDataLength(i[a])>0)}async hashDelayRevealPassword(t,a){let e=await this.contractWrapper.getChainID(),r=this.contractWrapper.address;return c.keccak256(["string","uint256","uint256","address"],[a,e,t,r])}async getNftMetadata(t){return(0,u.c)(this.contractWrapper.address,this.contractWrapper.getProvider(),t,this.storage)}async isLegacyContract(){if((0,r.h)("contractVersion",this.contractWrapper))try{return await this.contractWrapper.read("contractVersion",[])<=2}catch(t){}return!1}async getLegacyEncryptedData(t){let a=(await e.e(4601).then(e.t.bind(e,34601,19))).default,r=new h.NZ(this.contractWrapper.address,a,this.contractWrapper.getProvider()),n=await r.functions.encryptedBaseURI(t);return n.length>0?n[0]:"0x"}}async function W(t,a,e,r,n){let o={},i=r||s.aV,c=(await (0,g.n)(t.getProvider(),a,i)).mul(e);return c.gt(0)&&(i===s.aV?o={value:c}:i!==s.aV&&n&&await (0,y.a)(t,i,c,e,0)),o}class I{featureName=s.d6.name;constructor(t){this.contractWrapper=t}async get(){return this.contractWrapper.read("owner",[])}set=(0,n.f)(async t=>{let a=await (0,s.aL)(t);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setOwner",args:[a]})})}}}]);